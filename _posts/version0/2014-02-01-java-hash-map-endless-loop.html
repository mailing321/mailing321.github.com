---
layout : post
title : Java HashMap的死循环
---
<p>当你开始设计数据库的时候，第一件事，就是分析，你设计的数据库，是为那种类型的数据库提供服务的。具体来说，到底是事务型（Transactional）还是分析型（Analytical）。你可以发现，很多developer根本就不管自己的应用到底是那种类型，就直接按照“范式”的规定设计，最终，碰上了各种各样的性能、用户化问题。正如所说，有两种应用类型：基于事务的、基于分析的。让我来简单地介绍下这两种类型。
<p>
事务型： 这种类型的应用程序，最终用户更专注增删查改操作。这种类型叫做OLTP。
<p>
分析型： 这种类型的应用程序，最终用户更专注于对数据库存储的数据进行分析，并生成报告和进行预测。这时，数据库很少需要执行insert和remove操作。设计的主要目的，在于以最快的速度从数据库取数据，并进行分析。这种类型叫做OLAP。
<p>注意这些部分依赖主键的字段。如图，主键是（Roll Number，Standard）。这张表中，Syllabus 部分依赖于 Standard。注意 Syllabus 字段：Syllabus 通过 Standard 联系起来，而不是通过 Student 直接联系起来。
<p>
倘若 Syllabus 直接与 Student本身联系，那么，倘若某一天，我想要更新某个 Syllabus 字段，我必须将与之对应的所有 Student 更新一次。这既麻烦，也毫无逻辑。因此，把 Syllabus 独立一个表出来，并与 Standard 而不是 Sudent 联系起来，这样更有意义。
<p>
这条准则其实就是“第二范式”的表述：全部属性必须完全依赖主键，不可以部分依